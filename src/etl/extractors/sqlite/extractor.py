"""SQLite extractor for IMDB database.

Extracts horror movies from IMDB SQLite database
using native SQL queries (validates C2 competency).
"""

import sqlite3
from collections.abc import Iterator
from pathlib import Path

from src.etl.extractors.base import BaseExtractor
from src.etl.extractors.sqlite.queries import IMDBQueries
from src.etl.types import ETLResult
from src.etl.types.imdb import (
    IMDBExtractionResult,
    IMDBHorrorMovieJoined,
)


class SQLiteExtractor(BaseExtractor):
    """Extracts horror movies from IMDB SQLite database.

    Uses native SQL queries for C2 competency validation.
    Requires imdb.db generated by imdb-sqlite package.

    Attributes:
        name: Extractor identifier.
    """

    name = "imdb_sqlite"

    def __init__(
        self,
        db_path: Path | None = None,
        min_votes: int = 1000,
        min_rating: float = 0.0,
    ) -> None:
        """Initialize SQLite extractor.

        Args:
            db_path: Path to SQLite database.
            min_votes: Minimum votes filter.
            min_rating: Minimum rating filter.
        """
        super().__init__()
        self._db_path = db_path or self._get_default_path()
        self._min_votes = min_votes
        self._min_rating = min_rating
        self._connection: sqlite3.Connection | None = None
        self._horror_count: int = 0
        self._with_ratings: int = 0

    # -------------------------------------------------------------------------
    # Main Extraction
    # -------------------------------------------------------------------------

    def extract(self, **kwargs: object) -> ETLResult:
        """Execute IMDB extraction.

        Kwargs:
            min_votes: Override minimum votes filter.
            min_rating: Override minimum rating filter.

        Returns:
            ETLResult with extraction statistics.
        """
        self._apply_kwargs(kwargs)

        if not self._validate_db_path():
            return self._create_error_result(f"Database not found: {self._db_path}")

        return self._execute_extraction()

    def _apply_kwargs(self, kwargs: dict[str, object]) -> None:
        """Apply kwargs overrides.

        Args:
            kwargs: Extraction parameters.
        """
        if "min_votes" in kwargs:
            self._min_votes = int(kwargs["min_votes"])  # type: ignore[arg-type]
        if "min_rating" in kwargs:
            self._min_rating = float(kwargs["min_rating"])  # type: ignore[arg-type]

    def _validate_db_path(self) -> bool:
        """Validate database path exists.

        Returns:
            True if database exists.
        """
        return self._db_path is not None and self._db_path.exists()

    def _execute_extraction(self) -> ETLResult:
        """Execute the extraction process.

        Returns:
            ETLResult with statistics.
        """
        self._start_extraction()
        self._logger.info(f"Connecting to IMDB: {self._db_path}")

        try:
            self._connect()
            self._extract_horror_movies()
        except Exception as e:
            self._log_error(f"Extraction failed: {e}")
        finally:
            self._disconnect()

        return self._end_extraction()

    def _extract_horror_movies(self) -> None:
        """Extract horror movies with ratings."""
        query = IMDBQueries.horror_movies_with_ratings(
            min_votes=self._min_votes,
            min_rating=self._min_rating,
        )

        cursor = self._execute_query(query)
        self._extracted_count = cursor.rowcount if cursor.rowcount >= 0 else 0

        # Count for stats
        for _ in cursor:
            self._horror_count += 1

        self._extracted_count = self._horror_count
        self._logger.info(f"Extracted {self._horror_count} horror movies")

    # -------------------------------------------------------------------------
    # Data Access Methods
    # -------------------------------------------------------------------------

    def extract_to_list(self) -> list[IMDBHorrorMovieJoined]:
        """Extract all horror movies as list.

        Returns:
            List of horror movie data.
        """
        if not self._validate_db_path():
            self._log_error(f"Database not found: {self._db_path}")
            return []

        self._connect()
        try:
            return self._fetch_horror_movies()
        finally:
            self._disconnect()

    def _fetch_horror_movies(self) -> list[IMDBHorrorMovieJoined]:
        """Fetch horror movies from database.

        Returns:
            List of joined horror movie data.
        """
        query = IMDBQueries.horror_movies_with_ratings(
            min_votes=self._min_votes,
            min_rating=self._min_rating,
        )

        cursor = self._execute_query(query)
        columns = [desc[0] for desc in cursor.description]

        results: list[IMDBHorrorMovieJoined] = []
        for row in cursor:
            results.append(self._row_to_dict(row, columns))

        self._logger.info(f"Fetched {len(results)} horror movies")
        return results

    def extract_batches(
        self,
        batch_size: int = 1000,
    ) -> Iterator[list[IMDBHorrorMovieJoined]]:
        """Yield batches of horror movies.

        Args:
            batch_size: Number of rows per batch.

        Yields:
            List of horror movie data per batch.
        """
        if not self._validate_db_path():
            self._log_error(f"Database not found: {self._db_path}")
            return

        self._connect()
        try:
            yield from self._fetch_batches(batch_size)
        finally:
            self._disconnect()

    def _fetch_batches(
        self,
        batch_size: int,
    ) -> Iterator[list[IMDBHorrorMovieJoined]]:
        """Fetch horror movies in batches.

        Args:
            batch_size: Rows per batch.

        Yields:
            Batch of horror movie data.
        """
        query = IMDBQueries.horror_movies_with_ratings(
            min_votes=self._min_votes,
            min_rating=self._min_rating,
        )

        cursor = self._execute_query(query)
        columns = [desc[0] for desc in cursor.description]

        batch: list[IMDBHorrorMovieJoined] = []
        for row in cursor:
            batch.append(self._row_to_dict(row, columns))

            if len(batch) >= batch_size:
                yield batch
                batch = []

        if batch:
            yield batch

    # -------------------------------------------------------------------------
    # Specific Queries (C2 Validation)
    # -------------------------------------------------------------------------

    def get_top_rated_horror(self, limit: int = 100) -> list[IMDBHorrorMovieJoined]:
        """Get top rated horror movies.

        Demonstrates ORDER BY and LIMIT SQL clauses.

        Args:
            limit: Maximum results.

        Returns:
            List of top rated horror movies.
        """
        self._connect()
        try:
            query = IMDBQueries.top_rated_horror(
                min_votes=self._min_votes,
                limit=limit,
            )
            return self._execute_and_fetch(query)
        finally:
            self._disconnect()

    def get_horror_by_decade(self, decade: int) -> list[IMDBHorrorMovieJoined]:
        """Get horror movies by decade.

        Demonstrates BETWEEN clause.

        Args:
            decade: Start year of decade (e.g., 1980).

        Returns:
            List of horror movies from that decade.
        """
        self._connect()
        try:
            query = IMDBQueries.horror_by_decade(
                decade=decade,
                min_votes=self._min_votes,
            )
            return self._execute_and_fetch(query)
        finally:
            self._disconnect()

    def get_horror_stats(self) -> dict[str, float | int]:
        """Get aggregate statistics for horror movies.

        Demonstrates AVG, COUNT, MIN, MAX aggregations.

        Returns:
            Dictionary with statistics.
        """
        self._connect()
        try:
            query = IMDBQueries.horror_statistics(min_votes=self._min_votes)
            cursor = self._execute_query(query)
            row = cursor.fetchone()

            if row is None:
                return {}

            columns = [desc[0] for desc in cursor.description]
            return dict(zip(columns, row, strict=False))
        finally:
            self._disconnect()

    def _execute_and_fetch(self, query: str) -> list[IMDBHorrorMovieJoined]:
        """Execute query and fetch all results.

        Args:
            query: SQL query string.

        Returns:
            List of results as dictionaries.
        """
        cursor = self._execute_query(query)
        columns = [desc[0] for desc in cursor.description]

        return [self._row_to_dict(row, columns) for row in cursor]

    # -------------------------------------------------------------------------
    # Database Connection
    # -------------------------------------------------------------------------

    def _connect(self) -> None:
        """Establish database connection."""
        if self._connection is None:
            self._connection = sqlite3.connect(str(self._db_path))
            self._connection.row_factory = sqlite3.Row
            self._logger.debug("Connected to IMDB database")

    def _disconnect(self) -> None:
        """Close database connection."""
        if self._connection is not None:
            self._connection.close()
            self._connection = None
            self._logger.debug("Disconnected from IMDB database")

    def _execute_query(self, query: str) -> sqlite3.Cursor:
        """Execute SQL query.

        Args:
            query: SQL query string.

        Returns:
            Cursor with results.
        """
        if self._connection is None:
            raise RuntimeError("Database not connected")

        self._logger.debug(f"Executing query: {query[:100]}...")
        return self._connection.execute(query)

    # -------------------------------------------------------------------------
    # Helpers
    # -------------------------------------------------------------------------

    @staticmethod
    def _row_to_dict(
        row: sqlite3.Row,
        columns: list[str],
    ) -> IMDBHorrorMovieJoined:
        """Convert row to dictionary.

        Args:
            row: SQLite row.
            columns: Column names.

        Returns:
            Dictionary with column names as keys.
        """
        return dict(zip(columns, row, strict=False))  # type: ignore[return-value]

    def _get_default_path(self) -> Path | None:
        """Get default database path from settings.

        Returns:
            Path or None if not configured.
        """
        try:
            from src.settings.sources.imdb import IMDBSettings

            return IMDBSettings().sqlite_path
        except ImportError:
            return None

    def _create_error_result(self, message: str) -> ETLResult:
        """Create error ETLResult.

        Args:
            message: Error message.

        Returns:
            ETLResult with error.
        """
        self._log_error(message)
        return ETLResult(
            source=self.name,
            success=False,
            count=0,
            errors=[message],
            duration_seconds=0.0,
        )

    # -------------------------------------------------------------------------
    # Statistics
    # -------------------------------------------------------------------------

    def get_extraction_stats(self) -> IMDBExtractionResult:
        """Get detailed extraction statistics.

        Returns:
            IMDBExtractionResult with counts.
        """
        return IMDBExtractionResult(
            total_titles=0,
            horror_movies=self._horror_count,
            with_ratings=self._with_ratings,
            matched_films=0,
            duration_seconds=self._calculate_duration(),
        )
